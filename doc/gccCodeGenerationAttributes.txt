Next: Attribute Syntax, Previous: Mixed Declarations, Up: C Extensions 


--------------------------------------------------------------------------------

6.30 Declaring Attributes of Functions
In GNU C, you declare certain things about functions called in your program which help the compiler optimize function calls and check your code more carefully. 

The keyword __attribute__ allows you to specify special attributes when making a declaration. This keyword is followed by an attribute specification inside double parentheses. The following attributes are currently defined for functions on all targets: aligned, alloc_size, noreturn, returns_twice, noinline, noclone, always_inline, flatten, pure, const, nothrow, sentinel, format, format_arg, no_instrument_function, no_split_stack, section, constructor, destructor, used, unused, deprecated, weak, malloc, alias, ifunc, warn_unused_result, nonnull, gnu_inline, externally_visible, hot, cold, artificial, error and warning. Several other attributes are defined for functions on particular target systems. Other attributes, including section are supported for variables declarations (see Variable Attributes) and for types (see Type Attributes). 

GCC plugins may provide their own attributes. 

You may also specify attributes with `__' preceding and following each keyword. This allows you to use them in header files without being concerned about a possible macro of the same name. For example, you may use __noreturn__ instead of noreturn. 

See Attribute Syntax, for details of the exact syntax for using attributes. 

alias ("target")
The alias attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance, 
          void __f () { /* Do something. */; }
          void f () __attribute__ ((weak, alias ("__f")));
     
defines `f' to be a weak alias for `__f'. In C++, the mangled name for the target must be used. It is an error if `__f' is not defined in the same translation unit. 

Not all target machines support this attribute. 


aligned (alignment)
This attribute specifies a minimum alignment for the function, measured in bytes. 
You cannot use this attribute to decrease the alignment of a function, only to increase it. However, when you explicitly specify a function alignment this will override the effect of the -falign-functions (see Optimize Options) option for this function. 

Note that the effectiveness of aligned attributes may be limited by inherent limitations in your linker. On many systems, the linker is only able to arrange for functions to be aligned up to a certain maximum alignment. (For some linkers, the maximum supported alignment may be very very small.) See your linker documentation for further information. 

The aligned attribute can also be used for variables and fields (see Variable Attributes.) 


alloc_size
The alloc_size attribute is used to tell the compiler that the function return value points to memory, where the size is given by one or two of the functions parameters. GCC uses this information to improve the correctness of __builtin_object_size. 
The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one. 

For instance, 

          void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
          void my_realloc(void*, size_t) __attribute__((alloc_size(2)))
     
declares that my_calloc will return memory of the size given by the product of parameter 1 and 2 and that my_realloc will return memory of the size given by parameter 2. 


always_inline
Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function even if no optimization level was specified. 

gnu_inline
This attribute should be used with a function which is also declared with the inline keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode. 
If the function is declared extern, then this definition of the function is used only for inlining. In no case is the function compiled as a standalone function, not even if you take its address explicitly. Such an address becomes an external reference, as if you had only declared the function, and had not defined it. This has almost the effect of a macro. The way to use this is to put a function definition in a header file with this attribute, and put another copy of the function, without extern, in a library file. The definition in the header file will cause most calls to the function to be inlined. If any uses of the function remain, they will refer to the single copy in the library. Note that the two definitions of the functions need not be precisely the same, although if they do not have the same effect your program may behave oddly. 

In C, if the function is neither extern nor static, then the function is compiled as a standalone function, as well as being inlined where possible. 

This is how GCC traditionally handled functions declared inline. Since ISO C99 specifies a different semantics for inline, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros __GNUC_GNU_INLINE__ or __GNUC_STDC_INLINE__ are defined. See An Inline Function is As Fast As a Macro. 

In C++, this attribute does not depend on extern in any way, but it still requires the inline keyword to enable its special behavior. 


artificial
This attribute is useful for small inline wrappers which if possible should appear during debugging as a unit, depending on the debug info format it will either mean marking the function as artificial or using the caller location for all instructions within the inlined body. 

bank_switch
When added to an interrupt handler with the M32C port, causes the prologue and epilogue to use bank switching to preserve the registers rather than saving them on the stack. 

flatten
Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function will be inlined, if possible. Whether the function itself is considered for inlining depends on its size and the current inlining parameters. 

error ("message")
If this attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error which will include message will be diagnosed. This is useful for compile time checking, especially together with __builtin_constant_p and inline functions where checking the inline function arguments is not possible through extern char [(condition) ? 1 : -1]; tricks. While it is possible to leave the function undefined and thus invoke a link failure, when using this attribute the problem will be diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information. 

warning ("message")
If this attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, a warning which will include message will be diagnosed. This is useful for compile time checking, especially together with __builtin_constant_p and inline functions. While it is possible to define the function with a message in .gnu.warning* section, when using this attribute the problem will be diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information. 

cdecl
On the Intel 386, the cdecl attribute causes the compiler to assume that the calling function will pop off the stack space used to pass arguments. This is useful to override the effects of the -mrtd switch. 

const
Many functions do not examine any values except their arguments, and have no effects except the return value. Basically this is just slightly more strict class than the pure attribute below, since function is not allowed to read global memory. 
Note that a function that has pointer arguments and examines the data pointed to must not be declared const. Likewise, a function that calls a non-const function usually must not be const. It does not make sense for a const function to return void. 

The attribute const is not implemented in GCC versions earlier than 2.5. An alternative way to declare that a function has no side effects, which works in the current version and in some older versions, is as follows: 

          typedef int intfn ();
          
          extern const intfn square;
     
This approach does not work in GNU C++ from 2.6.0 on, since the language specifies that the `const' must be attached to the return value. 


constructor
destructor
constructor (priority)
destructor (priority)
The constructor attribute causes the function to be called automatically before execution enters main (). Similarly, the destructor attribute causes the function to be called automatically after main () has completed or exit () has been called. Functions with these attributes are useful for initializing data that will be used implicitly during the execution of the program. 
You may provide an optional integer priority to control the order in which constructor and destructor functions are run. A constructor with a smaller priority number runs before a constructor with a larger priority number; the opposite relationship holds for destructors. So, if you have a constructor that allocates a resource and a destructor that deallocates the same resource, both functions typically have the same priority. The priorities for constructor and destructor functions are the same as those specified for namespace-scope C++ objects (see C++ Attributes). 

These attributes are not currently implemented for Objective-C. 


deprecated
deprecated (msg)
The deprecated attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses: 
          int old_fn () __attribute__ ((deprecated));
          int old_fn ();
          int (*fn_ptr)() = old_fn;
     
results in a warning on line 3 but not line 2. The optional msg argument, which must be a string, will be printed in the warning if present. 

The deprecated attribute can also be used for variables and types (see Variable Attributes, see Type Attributes.) 


disinterrupt
On Epiphany and MeP targets, this attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function. 

dllexport
On Microsoft Windows targets and Symbian OS targets the dllexport attribute causes the compiler to provide a global pointer to a pointer in a DLL, so that it can be referenced with the dllimport attribute. On Microsoft Windows targets, the pointer name is formed by combining _imp__ and the function or variable name. 
You can use __declspec(dllexport) as a synonym for __attribute__ ((dllexport)) for compatibility with other compilers. 

On systems that support the visibility attribute, this attribute also implies “default” visibility. It is an error to explicitly specify any other visibility. 

In previous versions of GCC, the dllexport attribute was ignored for inlined functions, unless the -fkeep-inline-functions flag had been used. The default behaviour now is to emit all dllexported inline functions; however, this can cause object file-size bloat, in which case the old behaviour can be restored by using -fno-keep-inline-dllexport. 

The attribute is also ignored for undefined symbols. 

When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class. 

For Microsoft Windows targets there are alternative methods for including the symbol in the DLL's export table such as using a .def file with an EXPORTS section or, with GNU ld, using the --export-all linker flag. 


dllimport
On Microsoft Windows and Symbian OS targets, the dllimport attribute causes the compiler to reference a function or variable via a global pointer to a pointer that is set up by the DLL exporting the symbol. The attribute implies extern. On Microsoft Windows targets, the pointer name is formed by combining _imp__ and the function or variable name. 
You can use __declspec(dllimport) as a synonym for __attribute__ ((dllimport)) for compatibility with other compilers. 

On systems that support the visibility attribute, this attribute also implies “default” visibility. It is an error to explicitly specify any other visibility. 

Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol definition, an error is reported. If a symbol previously declared dllimport is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as dllexport. 

When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks. 

On the SH Symbian OS target the dllimport attribute also has another affect—it can cause the vtable and run-time type information for a class to be exported. This happens when the class has a dllimport'ed constructor or a non-inline, non-pure virtual function and, for either of those two conditions, the class also has an inline constructor or destructor and has a key function that is defined in the current translation unit. 

For Microsoft Windows based targets the use of the dllimport attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the dllimport attribute on imported variables was required on older versions of the GNU linker, but can now be avoided by passing the --enable-auto-import switch to the GNU linker. As with functions, using the attribute for a variable eliminates a thunk in the DLL. 

One drawback to using this attribute is that a pointer to a variable marked as dllimport cannot be used as a constant address. However, a pointer to a function with the dllimport attribute can be used as a constant initializer; in this case, the address of a stub function in the import lib is referenced. On Microsoft Windows targets, the attribute can be disabled for functions by setting the -mnop-fun-dllimport flag. 


eightbit_data
Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified variable should be placed into the eight bit data section. The compiler will generate more efficient code for certain operations on data in the eight bit data area. Note the eight bit data area is limited to 256 bytes of data. 
You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly. 


exception_handler
Use this attribute on the Blackfin to indicate that the specified function is an exception handler. The compiler will generate function entry and exit sequences suitable for use in an exception handler when this attribute is present. 

externally_visible
This attribute, attached to a global variable or function, nullifies the effect of the -fwhole-program command-line option, so the object remains visible outside the current compilation unit. If -fwhole-program is used together with -flto and gold is used as the linker plugin, externally_visible attributes are automatically added to functions (not variable yet due to a current gold issue) that are accessed outside of LTO objects according to resolution file produced by gold. For other linkers that cannot generate resolution file, explicit externally_visible attributes are still necessary. 

far
On 68HC11 and 68HC12 the far attribute causes the compiler to use a calling convention that takes care of switching memory banks when entering and leaving a function. This calling convention is also the default when using the -mlong-calls option. 
On 68HC12 the compiler will use the call and rtc instructions to call and return from a function. 

On 68HC11 the compiler will generate a sequence of instructions to invoke a board-specific routine to switch the memory bank and call the real function. The board-specific routine simulates a call. At the end of a function, it will jump to a board-specific routine instead of using rts. The board-specific return routine simulates the rtc. 

On MeP targets this causes the compiler to use a calling convention which assumes the called function is too far away for the built-in addressing modes. 


fast_interrupt
Use this attribute on the M32C and RX ports to indicate that the specified function is a fast interrupt handler. This is just like the interrupt attribute, except that freit is used to return instead of reit. 

fastcall
On the Intel 386, the fastcall attribute causes the compiler to pass the first argument (if of integral type) in the register ECX and the second argument (if of integral type) in the register EDX. Subsequent and other typed arguments are passed on the stack. The called function will pop the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack. 

thiscall
On the Intel 386, the thiscall attribute causes the compiler to pass the first argument (if of integral type) in the register ECX. Subsequent and other typed arguments are passed on the stack. The called function will pop the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack. The thiscall attribute is intended for C++ non-static member functions. As gcc extension this calling convention can be used for C-functions and for static member methods. 

format (archetype, string-index, first-to-check)
The format attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments which should be type-checked against a format string. For example, the declaration: 
          extern int
          my_printf (void *my_object, const char *my_format, ...)
                __attribute__ ((format (printf, 2, 3)));
     
causes the compiler to check the arguments in calls to my_printf for consistency with the printf style format string argument my_format. 

The parameter archetype determines how the format string is interpreted, and should be printf, scanf, strftime, gnu_printf, gnu_scanf, gnu_strftime or strfmon. (You can also use __printf__, __scanf__, __strftime__ or __strfmon__.) On MinGW targets, ms_printf, ms_scanf, and ms_strftime are also present. archtype values such as printf refer to the formats accepted by the system's C run-time library, while gnu_ values always refer to the formats accepted by the GNU C Library. On Microsoft Windows targets, ms_ values refer to the formats accepted by the msvcrt.dll library. The parameter string-index specifies which argument is the format string argument (starting from 1), while first-to-check is the number of the first argument to check against the format string. For functions where the arguments are not available to be checked (such as vprintf), specify the third parameter as zero. In this case the compiler only checks the format string for consistency. For strftime formats, the third parameter is required to be zero. Since non-static C++ methods have an implicit this argument, the arguments of such methods should be counted from two, not one, when giving values for string-index and first-to-check. 

In the example above, the format string (my_format) is the second argument of the function my_print, and the arguments to check start with the third argument, so the correct parameters for the format attribute are 2 and 3. 

The format attribute allows you to identify your own functions which take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless -ffreestanding or -fno-builtin is used) checks formats for the standard library functions printf, fprintf, sprintf, scanf, fscanf, sscanf, strftime, vprintf, vfprintf and vsprintf whenever such warnings are requested (using -Wformat), so there is no need to modify the header file stdio.h. In C99 mode, the functions snprintf, vsnprintf, vscanf, vfscanf and vsscanf are also checked. Except in strictly conforming C standard modes, the X/Open function strfmon is also checked as are printf_unlocked and fprintf_unlocked. See Options Controlling C Dialect. 

For Objective-C dialects, NSString (or __NSString__) is recognized in the same context. Declarations including these format attributes will be parsed for correct syntax, however the result of checking of such format strings is not yet defined, and will not be carried out by this version of the compiler. 

The target may also provide additional types of format checks. See Format Checks Specific to Particular Target Machines. 


format_arg (string-index)
The format_arg attribute specifies that a function takes a format string for a printf, scanf, strftime or strfmon style function and modifies it (for example, to translate it into another language), so the result can be passed to a printf, scanf, strftime or strfmon style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). For example, the declaration: 
          extern char *
          my_dgettext (char *my_domain, const char *my_format)
                __attribute__ ((format_arg (2)));
     
causes the compiler to check the arguments in calls to a printf, scanf, strftime or strfmon type function, whose format string argument is a call to the my_dgettext function, for consistency with the format string argument my_format. If the format_arg attribute had not been specified, all the compiler could tell in such calls to format functions would be that the format string argument is not constant; this would generate a warning when -Wformat-nonliteral is used, but the calls could not be checked without the attribute. 

The parameter string-index specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit this argument, the arguments of such methods should be counted from two. 

The format-arg attribute allows you to identify your own functions which modify format strings, so that GCC can check the calls to printf, scanf, strftime or strfmon type function whose operands are a call to one of your own function. The compiler always treats gettext, dgettext, and dcgettext in this manner except when strict ISO C support is requested by -ansi or an appropriate -std option, or -ffreestanding or -fno-builtin is used. See Options Controlling C Dialect. 

For Objective-C dialects, the format-arg attribute may refer to an NSString reference for compatibility with the format attribute above. 

The target may also allow additional types in format-arg attributes. See Format Checks Specific to Particular Target Machines. 


function_vector
Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified function should be called through the function vector. Calling a function through the function vector will reduce code size, however; the function vector has a limited size (maximum 128 entries on the H8/300 and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector. 
In SH2A target, this attribute declares a function to be called using the TBR relative addressing mode. The argument to this attribute is the entry number of the same function in a vector table containing all the TBR relative addressable functions. For the successful jump, register TBR should contain the start address of this TBR relative vector table. In the startup routine of the user application, user needs to care of this TBR register initialization. The TBR relative vector table can have at max 256 function entries. The jumps to these functions will be generated using a SH2A specific, non delayed branch instruction JSR/N @(disp8,TBR). You must use GAS and GLD from GNU binutils version 2.7 or later for this attribute to work correctly. 

Please refer the example of M16C target, to see the use of this attribute while declaring a function, 

In an application, for a function being called once, this attribute will save at least 8 bytes of code; and if other successive calls are being made to the same function, it will save 2 bytes of code per each of these calls. 

On M16C/M32C targets, the function_vector attribute declares a special page subroutine call function. Use of this attribute reduces the code size by 2 bytes for each call generated to the subroutine. The argument to the attribute is the vector number entry from the special page vector table which contains the 16 low-order bits of the subroutine's entry address. Each vector table has special page number (18 to 255) which are used in jsrs instruction. Jump addresses of the routines are generated by adding 0x0F0000 (in case of M16C targets) or 0xFF0000 (in case of M32C targets), to the 2 byte addresses set in the vector table. Therefore you need to ensure that all the special page vector routines should get mapped within the address range 0x0F0000 to 0x0FFFFF (for M16C) and 0xFF0000 to 0xFFFFFF (for M32C). 

In the following example 2 bytes will be saved for each call to function foo. 

          void foo (void) __attribute__((function_vector(0x18)));
          void foo (void)
          {
          }
          
          void bar (void)
          {
              foo();
          }
     
If functions are defined in one file and are called in another file, then be sure to write this declaration in both files. 

This attribute is ignored for R8C target. 


ifunc ("resolver")
The ifunc attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine can be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions' declarations must match the API of the function being implemented, the resolver's declaration is be a function returning pointer to void function returning void: 
          void *my_memcpy (void *dst, const void *src, size_t len)
          {
            ...
          }
          
          static void (*resolve_memcpy (void)) (void)
          {
            return my_memcpy; // we'll just always select this routine
          }
     
The exported header file declaring the function the user calls would contain: 

          extern void *memcpy (void *, const void *, size_t);
     
allowing the user to call this as a regular function, unaware of the implementation. Finally, the indirect function needs to be defined in the same translation unit as the resolver function: 

          void *memcpy (void *, const void *, size_t)
               __attribute__ ((ifunc ("resolve_memcpy")));
     
Indirect functions cannot be weak, and require a recent binutils (at least version 2.20.1), and GNU C library (at least version 2.11.1). 


interrupt
Use this attribute on the ARM, AVR, CR16, Epiphany, M32C, M32R/D, m68k, MeP, MIPS, RL78, RX and Xstormy16 ports to indicate that the specified function is an interrupt handler. The compiler will generate function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. With Epiphany targets it may also generate a special section with code to initialize the interrupt vector table. 
Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S, MicroBlaze, and SH processors can be specified via the interrupt_handler attribute. 

Note, on the AVR, the hardware globally disables interrupts when an interrupt is executed. The first instruction of an interrupt handler declared with this attribute will be a SEI instruction to re-enable interrupts. See also the signal function attribute that does not insert a SEI instuction. If both signal and interrupt are specified for the same function, signal will be silently ignored. 

Note, for the ARM, you can specify the kind of interrupt to be handled by adding an optional parameter to the interrupt attribute like this: 

          void f () __attribute__ ((interrupt ("IRQ")));
     
Permissible values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF. 

On ARMv7-M the interrupt type is ignored, and the attribute means the function may be called with a word aligned stack pointer. 

On Epiphany targets one or more optional parameters can be added like this: 

          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
     
Permissible values for these parameters are: reset, software_exception, page_miss, timer0, timer1, message, dma0, dma1, wand and swi. Multiple parameters indicate that multiple entries in the interrupt vector table should be initialized for this function, i.e. for each parameter name, a jump to the function will be emitted in the section ivt_entry_name. The parameter(s) may be omitted entirely, in which case no interrupt vector table entry will be provided. 

Note, on Epiphany targets, interrupts are enabled inside the function unless the disinterrupt attribute is also specified. 

On Epiphany targets, you can also use the following attribute to modify the behavior of an interrupt handler: 

forwarder_section
The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline will be placed. 
The following examples are all valid uses of these attributes on Epiphany targets: 

          void __attribute__ ((interrupt)) universal_handler ();
          void __attribute__ ((interrupt ("dma1"))) dma1_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
          void __attribute__ ((interrupt ("timer0"), disinterrupt))
            fast_timer_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"), forwarder_section ("tramp")))
            external_dma_handler ();
     
On MIPS targets, you can use the following attributes to modify the behavior of an interrupt handler: 

use_shadow_register_set
Assume that the handler uses a shadow register set, instead of the main general-purpose registers. 

keep_interrupts_masked
Keep interrupts masked for the whole function. Without this attribute, GCC tries to reenable interrupts for as much of the function as it can. 

use_debug_exception_return
Return using the deret instruction. Interrupt handlers that don't have this attribute return using eret instead. 
You can use any combination of these attributes, as shown below: 

          void __attribute__ ((interrupt)) v0 ();
          void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
          void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
          void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked)) v4 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               use_debug_exception_return)) v5 ();
          void __attribute__ ((interrupt, keep_interrupts_masked,
                               use_debug_exception_return)) v6 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked,
                               use_debug_exception_return)) v7 ();
     
On RL78, use brk_interrupt instead of interrupt for handlers intended to be used with the BRK opcode (i.e. those that must end with RETB instead of RETI). 


interrupt_handler
Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and SH to indicate that the specified function is an interrupt handler. The compiler will generate function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. 

interrupt_thread
Use this attribute on fido, a subarchitecture of the m68k, to indicate that the specified function is an interrupt handler that is designed to run as a thread. The compiler omits generate prologue/epilogue sequences and replaces the return instruction with a sleep instruction. This attribute is available only on fido. 

isr
Use this attribute on ARM to write Interrupt Service Routines. This is an alias to the interrupt attribute above. 

kspisusp
When used together with interrupt_handler, exception_handler or nmi_handler, code will be generated to load the stack pointer from the USP register in the function prologue. 

l1_text
This attribute specifies a function to be placed into L1 Instruction SRAM. The function will be put into a specific section named .l1.text. With -mfdpic, function calls with a such function as the callee or caller will use inlined PLT. 

l2
On the Blackfin, this attribute specifies a function to be placed into L2 SRAM. The function will be put into a specific section named .l1.text. With -mfdpic, callers of such functions will use an inlined PLT. 

leaf
Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, leaf functions are not allowed to call callback function passed to it from the current compilation unit or directly call functions exported by the unit or longjmp into the unit. Leaf function might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all. 
The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit can not be used or modified by the leaf function. For example, the sin function is a leaf function, but qsort is not. 

Note that leaf functions might invoke signals and signal handlers might be defined in the current compilation unit and use static variables. The only compliant way to write such a signal handler is to declare such variables volatile. 

The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link time optimization. For this reason the attribute is not allowed on types to annotate indirect calls. 


long_call/short_call
This attribute specifies how a particular function is called on ARM and Epiphany. Both attributes override the -mlong-calls (see ARM Options) command-line switch and #pragma long_calls settings. The long_call attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The short_call attribute always places the offset to the function from the call site into the `BL' instruction directly. 

longcall/shortcall
On the Blackfin, RS/6000 and PowerPC, the longcall attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The shortcall attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the -mlongcall switch and, on the RS/6000 and PowerPC, the #pragma longcall setting. 
See RS/6000 and PowerPC Options, for more information on whether long calls are necessary. 


long_call/near/far
These attributes specify how a particular function is called on MIPS. The attributes override the -mlong-calls (see MIPS Options) command-line switch. The long_call and far attributes are synonyms, and cause the compiler to always call the function by first loading its address into a register, and then using the contents of that register. The near attribute has the opposite effect; it specifies that non-PIC calls should be made using the more efficient jal instruction. 

malloc
The malloc attribute is used to tell the compiler that a function may be treated as if any non-NULL pointer it returns cannot alias any other pointer valid when the function returns and that the memory has undefined content. This will often improve optimization. Standard functions with this property include malloc and calloc. realloc-like functions do not have this property as the memory pointed to does not have undefined content. 

mips16/nomips16
On MIPS targets, you can use the mips16 and nomips16 function attributes to locally select or turn off MIPS16 code generation. A function with the mips16 attribute is emitted as MIPS16 code, while MIPS16 code generation is disabled for functions with the nomips16 attribute. These attributes override the -mips16 and -mno-mips16 options on the command line (see MIPS Options). 
When compiling files containing mixed MIPS16 and non-MIPS16 code, the preprocessor symbol __mips16 reflects the setting on the command line, not that within individual functions. Mixed MIPS16 and non-MIPS16 code may interact badly with some GCC extensions such as __builtin_apply (see Constructing Calls). 


model (model-name)
On the M32R/D, use this attribute to set the addressability of an object, and of the code generated for a function. The identifier model-name is one of small, medium, or large, representing each of the code models. 
Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the ld24 instruction), and are callable with the bl instruction. 

Medium model objects may live anywhere in the 32-bit address space (the compiler will generate seth/add3 instructions to load their addresses), and are callable with the bl instruction. 

Large model objects may live anywhere in the 32-bit address space (the compiler will generate seth/add3 instructions to load their addresses), and may not be reachable with the bl instruction (the compiler will generate the much slower seth/add3/jl instruction sequence). 

On IA-64, use this attribute to set the addressability of an object. At present, the only supported identifier for model-name is small, indicating addressability via “small” (22-bit) addresses (so that their addresses can be loaded with the addl instruction). Caveat: such addressing is by definition not position independent and hence this attribute must not be used for objects defined by shared libraries. 


ms_abi/sysv_abi
On 32-bit and 64-bit (i?86|x86_64)-*-* targets, you can use an ABI attribute to indicate which calling convention should be used for a function. The ms_abi attribute tells the compiler to use the Microsoft ABI, while the sysv_abi attribute tells the compiler to use the ABI used on GNU/Linux and other systems. The default is to use the Microsoft ABI when targeting Windows. On all other systems, the default is the x86/AMD ABI. 
Note, the ms_abi attribute for Windows 64-bit targets currently requires the -maccumulate-outgoing-args option. 


callee_pop_aggregate_return (number)
On 32-bit i?86-*-* targets, you can control by those attribute for aggregate return in memory, if the caller is responsible to pop the hidden pointer together with the rest of the arguments - number equal to zero -, or if the callee is responsible to pop hidden pointer - number equal to one. The default i386 ABI assumes that the callee pops the stack for hidden pointer. 
Note, that on 32-bit i386 Windows targets the compiler assumes that the caller pops the stack for hidden pointer. 


ms_hook_prologue
On 32 bit i[34567]86-*-* targets and 64 bit x86_64-*-* targets, you can use this function attribute to make gcc generate the "hot-patching" function prologue used in Win32 API functions in Microsoft Windows XP Service Pack 2 and newer. 

naked
Use this attribute on the ARM, AVR, MCORE, RX and SPU ports to indicate that the specified function does not need prologue/epilogue sequences generated by the compiler. It is up to the programmer to provide these sequences. The only statements that can be safely included in naked functions are asm statements that do not have operands. All other statements, including declarations of local variables, if statements, and so forth, should be avoided. Naked functions should be used to implement the body of an assembly function, while allowing the compiler to construct the requisite function declaration for the assembler. 

near
On 68HC11 and 68HC12 the near attribute causes the compiler to use the normal calling convention based on jsr and rts. This attribute can be used to cancel the effect of the -mlong-calls option. 
On MeP targets this attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the -mtf command line option. 


nesting
Use this attribute together with interrupt_handler, exception_handler or nmi_handler to indicate that the function entry code should enable nested interrupts or exceptions. 

nmi_handler
Use this attribute on the Blackfin to indicate that the specified function is an NMI handler. The compiler will generate function entry and exit sequences suitable for use in an NMI handler when this attribute is present. 

no_instrument_function
If -finstrument-functions is given, profiling function calls will be generated at entry and exit of most user-compiled functions. Functions with this attribute will not be so instrumented. 

no_split_stack
If -fsplit-stack is given, functions will have a small prologue which decides whether to split the stack. Functions with the no_split_stack attribute will not have that prologue, and thus may run with only a small amount of stack space available. 

noinline
This function attribute prevents a function from being considered for inlining. If the function does not have side-effects, there are optimizations other than inlining that causes function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put 
          asm ("");
     
(see Extended Asm) in the called function, to serve as a special side-effect. 


noclone
This function attribute prevents a function from being considered for cloning - a mechanism which produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation. 

nonnull (arg-index, ...)
The nonnull attribute specifies that some function parameters should be non-null pointers. For instance, the declaration: 
          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull (1, 2)));
     
causes the compiler to check that, in calls to my_memcpy, arguments dest and src are non-null. If the compiler determines that a null pointer is passed in an argument slot marked as non-null, and the -Wnonnull option is enabled, a warning is issued. The compiler may also choose to make optimizations based on the knowledge that certain function arguments will not be null. 

If no argument index list is given to the nonnull attribute, all pointer arguments are marked as non-null. To illustrate, the following declaration is equivalent to the previous example: 

          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull));
     


noreturn
A few standard library functions, such as abort and exit, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them noreturn to tell the compiler this fact. For example, 
          void fatal () __attribute__ ((noreturn));
          
          void
          fatal (/* ... */)
          {
            /* ... */ /* Print error message. */ /* ... */
            exit (1);
          }
     
The noreturn keyword tells the compiler to assume that fatal cannot return. It can then optimize without regard to what would happen if fatal ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables. 

The noreturn keyword does not affect the exceptional path when that applies: a noreturn-marked function may still return to the caller by throwing an exception or calling longjmp. 

Do not assume that registers saved by the calling function are restored before calling the noreturn function. 

It does not make sense for a noreturn function to have a return type other than void. 

The attribute noreturn is not implemented in GCC versions earlier than 2.5. An alternative way to declare that a function does not return, which works in the current version and in some older versions, is as follows: 

          typedef void voidfn ();
          
          volatile voidfn fatal;
     
This approach does not work in GNU C++. 


nothrow
The nothrow attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of qsort and bsearch that take function pointer arguments. The nothrow attribute is not implemented in GCC versions earlier than 3.3. 

optimize
The optimize attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Arguments can either be numbers or strings. Numbers are assumed to be an optimization level. Strings that begin with O are assumed to be an optimization option, while other options are assumed to be used with a -f prefix. You can also use the `#pragma GCC optimize' pragma to set the optimization options that affect more than one function. See Function Specific Option Pragmas, for details about the `#pragma GCC optimize' pragma. 
This can be used for instance to have frequently executed functions compiled with more aggressive optimization options that produce faster and larger code, while other functions can be called with less aggressive options. 


OS_main/OS_task
On AVR, functions with the OS_main or OS_task attribute do not save/restore any call-saved register in their prologue/epilogue. 
The OS_main attribute can be used when there is guarantee that interrupts are disabled at the time when the function is entered. This will save resources when the stack pointer has to be changed to set up a frame for local variables. 

The OS_task attribute can be used when there is no guarantee that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register will be guarded by save/clear/restore of the global interrupt enable flag. 

The differences to the naked function attribute are: 

naked functions do not have a return instruction whereas OS_main and OS_task functions will have a RET or RETI return instruction. 
naked functions do not set up a frame for local variables or a frame pointer whereas OS_main and OS_task do this as needed. 


pcs
The pcs attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use. 
When compiling using the AAPCS ABI (or a variant of that) then valid values for the argument are "aapcs" and "aapcs-vfp". In order to use a variant other than "aapcs" then the compiler must be permitted to use the appropriate co-processor registers (i.e., the VFP registers must be available in order to use "aapcs-vfp"). For example, 

          /* Argument passed in r0, and result returned in r0+r1.  */
          double f2d (float) __attribute__((pcs("aapcs")));
     
Variadic functions always use the "aapcs" calling convention and the compiler will reject attempts to specify an alternative. 


pure
Many functions have no effects except the return value and their return value depends only on the parameters and/or global variables. Such a function can be subject to common subexpression elimination and loop optimization just as an arithmetic operator would be. These functions should be declared with the attribute pure. For example, 
          int square (int) __attribute__ ((pure));
     
says that the hypothetical function square is safe to call fewer times than the program says. 

Some of common examples of pure functions are strlen or memcmp. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between two consecutive calls (such as feof in a multithreading environment). 

The attribute pure is not implemented in GCC versions earlier than 2.96. 


hot
The hot attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many target it is placed into special subsection of the text section so all hot functions appears close together improving locality. 
When profile feedback is available, via -fprofile-use, hot functions are automatically detected and this attribute is ignored. 

The hot attribute on functions is not implemented in GCC versions earlier than 4.3. 

The hot attribute on a label is used to inform the compiler that path following the label are more likely than paths that are not so annotated. This attribute is used in cases where __builtin_expect cannot be used, for instance with computed goto or asm goto. 

The hot attribute on labels is not implemented in GCC versions earlier than 4.8. 


cold
The cold attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into special subsection of the text section so all cold functions appears close together improving code locality of non-cold parts of program. The paths leading to call of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as perror, as cold to improve optimization of hot functions that do call marked functions in rare occasions. 
When profile feedback is available, via -fprofile-use, cold functions are automatically detected and this attribute is ignored. 

The cold attribute on functions is not implemented in GCC versions earlier than 4.3. 

The cold attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where __builtin_expect cannot be used, for instance with computed goto or asm goto. 

The cold attribute on labels is not implemented in GCC versions earlier than 4.8. 


regparm (number)
On the Intel 386, the regparm attribute causes the compiler to pass arguments number one to number if they are of integral type in registers EAX, EDX, and ECX instead of on the stack. Functions that take a variable number of arguments will continue to be passed all of their arguments on the stack. 
Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding will send the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. GNU systems with GLIBC 2.1 or higher, and FreeBSD, are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.) 


sseregparm
On the Intel 386 with SSE support, the sseregparm attribute causes the compiler to pass up to 3 floating point arguments in SSE registers instead of on the stack. Functions that take a variable number of arguments will continue to pass all of their floating point arguments on the stack. 

force_align_arg_pointer
On the Intel x86, the force_align_arg_pointer attribute may be applied to individual function definitions, generating an alternate prologue and epilogue that realigns the runtime stack if necessary. This supports mixing legacy codes that run with a 4-byte aligned stack with modern codes that keep a 16-byte stack for SSE compatibility. 

resbank
On the SH2A target, this attribute enables the high-speed register saving and restoration using a register bank for interrupt_handler routines. Saving to the bank is performed automatically after the CPU accepts an interrupt that uses a register bank. 
The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction. 


returns_twice
The returns_twice attribute tells the compiler that a function may return more than one time. The compiler will ensure that all registers are dead before calling such a function and will emit a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are setjmp and vfork. The longjmp-like counterpart of such function, if any, might need to be marked with the noreturn attribute. 

saveall
Use this attribute on the Blackfin, H8/300, H8/300H, and H8S to indicate that all registers except the stack pointer should be saved in the prologue regardless of whether they are used or not. 

save_volatiles
Use this attribute on the MicroBlaze to indicate that the function is an interrupt handler. All volatile registers (in addition to non-volatile registers) will be saved in the function prologue. If the function is a leaf function, only volatiles used by the function are saved. A normal function return is generated instead of a return from interrupt. 

section ("section-name")
Normally, the compiler places the code it generates in the text section. Sometimes, however, you need additional sections, or you need certain particular functions to appear in special sections. The section attribute specifies that a function lives in a particular section. For example, the declaration: 
          extern void foobar (void) __attribute__ ((section ("bar")));
     
puts the function foobar in the bar section. 

Some file formats do not support arbitrary sections so the section attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead. 


sentinel
This function attribute ensures that a parameter in a function call is an explicit NULL. The attribute is only valid on variadic functions. By default, the sentinel is located at position zero, the last parameter of the function call. If an optional integer position argument P is supplied to the attribute, the sentinel must be located at position P counting backwards from the end of the argument list. 
          __attribute__ ((sentinel))
          is equivalent to
          __attribute__ ((sentinel(0)))
     
The attribute is automatically set with a position of 0 for the built-in functions execl and execlp. The built-in function execle has the attribute set with a position of 1. 

A valid NULL in this context is defined as zero with any pointer type. If your system defines the NULL macro with an integer type then you need to add an explicit cast. GCC replaces stddef.h with a copy that redefines NULL appropriately. 

The warnings for missing or incorrect sentinels are enabled with -Wformat. 


short_call
See long_call/short_call. 

shortcall
See longcall/shortcall. 

signal
Use this attribute on the AVR to indicate that the specified function is an interrupt handler. The compiler will generate function entry and exit sequences suitable for use in an interrupt handler when this attribute is present. 
See also the interrupt function attribute. 

The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the signal attribute do not re-enable interrupts. It is save to enable interrupts in a signal handler. This “save” only applies to the code generated by the compiler and not to the IRQ-layout of the application which is responsibility of the application. 

If both signal and interrupt are specified for the same function, signal will be silently ignored. 


sp_switch
Use this attribute on the SH to indicate an interrupt_handler function should switch to an alternate stack. It expects a string argument that names a global variable holding the address of the alternate stack. 
          void *alt_stack;
          void f () __attribute__ ((interrupt_handler,
                                    sp_switch ("alt_stack")));
     


stdcall
On the Intel 386, the stdcall attribute causes the compiler to assume that the called function will pop off the stack space used to pass arguments, unless it takes a variable number of arguments. 

syscall_linkage
This attribute is used to modify the IA64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code. 

target
The target attribute is used to specify that a function is to be compiled with different target options than specified on the command line. This can be used for instance to have functions compiled with a different ISA (instruction set architecture) than the default. You can also use the `#pragma GCC target' pragma to set more than one function to be compiled with specific target options. See Function Specific Option Pragmas, for details about the `#pragma GCC target' pragma. 
For instance on a 386, you could compile one function with target("sse4.1,arch=core2") and another with target("sse4a,arch=amdfam10") that would be equivalent to compiling the first function with -msse4.1 and -march=core2 options, and the second function with -msse4a and -march=amdfam10 options. It is up to the user to make sure that a function is only invoked on a machine that supports the particular ISA it was compiled for (for example by using cpuid on 386 to determine what feature bits and architecture family are used). 

          int core2_func (void) __attribute__ ((__target__ ("arch=core2")));
          int sse3_func (void) __attribute__ ((__target__ ("sse3")));
     
On the 386, the following options are allowed: 

`abm'
`no-abm'
Enable/disable the generation of the advanced bit instructions. 

`aes'
`no-aes'
Enable/disable the generation of the AES instructions. 

`mmx'
`no-mmx'
Enable/disable the generation of the MMX instructions. 

`pclmul'
`no-pclmul'
Enable/disable the generation of the PCLMUL instructions. 

`popcnt'
`no-popcnt'
Enable/disable the generation of the POPCNT instruction. 

`sse'
`no-sse'
Enable/disable the generation of the SSE instructions. 

`sse2'
`no-sse2'
Enable/disable the generation of the SSE2 instructions. 

`sse3'
`no-sse3'
Enable/disable the generation of the SSE3 instructions. 

`sse4'
`no-sse4'
Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2). 

`sse4.1'
`no-sse4.1'
Enable/disable the generation of the sse4.1 instructions. 

`sse4.2'
`no-sse4.2'
Enable/disable the generation of the sse4.2 instructions. 

`sse4a'
`no-sse4a'
Enable/disable the generation of the SSE4A instructions. 

`fma4'
`no-fma4'
Enable/disable the generation of the FMA4 instructions. 

`xop'
`no-xop'
Enable/disable the generation of the XOP instructions. 

`lwp'
`no-lwp'
Enable/disable the generation of the LWP instructions. 

`ssse3'
`no-ssse3'
Enable/disable the generation of the SSSE3 instructions. 

`cld'
`no-cld'
Enable/disable the generation of the CLD before string moves. 

`fancy-math-387'
`no-fancy-math-387'
Enable/disable the generation of the sin, cos, and sqrt instructions on the 387 floating point unit. 

`fused-madd'
`no-fused-madd'
Enable/disable the generation of the fused multiply/add instructions. 

`ieee-fp'
`no-ieee-fp'
Enable/disable the generation of floating point that depends on IEEE arithmetic. 

`inline-all-stringops'
`no-inline-all-stringops'
Enable/disable inlining of string operations. 

`inline-stringops-dynamically'
`no-inline-stringops-dynamically'
Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations. 

`align-stringops'
`no-align-stringops'
Do/do not align destination of inlined string operations. 

`recip'
`no-recip'
Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating point division. 

`arch=ARCH'
Specify the architecture to generate code for in compiling the function. 

`tune=TUNE'
Specify the architecture to tune for in compiling the function. 

`fpmath=FPMATH'
Specify which floating point unit to use. The target("fpmath=sse,387") option must be specified as target("fpmath=sse+387") because the comma would separate different options. 
On the PowerPC, the following options are allowed: 

`altivec'
`no-altivec'
Generate code that uses (does not use) AltiVec instructions. In 32-bit code, you cannot enable Altivec instructions unless -mabi=altivec was used on the command line. 

`cmpb'
`no-cmpb'
Generate code that uses (does not use) the compare bytes instruction implemented on the POWER6 processor and other processors that support the PowerPC V2.05 architecture. 

`dlmzb'
`no-dlmzb'
Generate code that uses (does not use) the string-search `dlmzb' instruction on the IBM 405, 440, 464 and 476 processors. This instruction is generated by default when targeting those processors. 

`fprnd'
`no-fprnd'
Generate code that uses (does not use) the FP round to integer instructions implemented on the POWER5+ processor and other processors that support the PowerPC V2.03 architecture. 

`hard-dfp'
`no-hard-dfp'
Generate code that uses (does not use) the decimal floating point instructions implemented on some POWER processors. 

`isel'
`no-isel'
Generate code that uses (does not use) ISEL instruction. 

`mfcrf'
`no-mfcrf'
Generate code that uses (does not use) the move from condition register field instruction implemented on the POWER4 processor and other processors that support the PowerPC V2.01 architecture. 

`mfpgpr'
`no-mfpgpr'
Generate code that uses (does not use) the FP move to/from general purpose register instructions implemented on the POWER6X processor and other processors that support the extended PowerPC V2.05 architecture. 

`mulhw'
`no-mulhw'
Generate code that uses (does not use) the half-word multiply and multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors. These instructions are generated by default when targeting those processors. 

`multiple'
`no-multiple'
Generate code that uses (does not use) the load multiple word instructions and the store multiple word instructions. 

`update'
`no-update'
Generate code that uses (does not use) the load or store instructions that update the base register to the address of the calculated memory location. 

`popcntb'
`no-popcntb'
Generate code that uses (does not use) the popcount and double precision FP reciprocal estimate instruction implemented on the POWER5 processor and other processors that support the PowerPC V2.02 architecture. 

`popcntd'
`no-popcntd'
Generate code that uses (does not use) the popcount instruction implemented on the POWER7 processor and other processors that support the PowerPC V2.06 architecture. 

`powerpc-gfxopt'
`no-powerpc-gfxopt'
Generate code that uses (does not use) the optional PowerPC architecture instructions in the Graphics group, including floating-point select. 

`powerpc-gpopt'
`no-powerpc-gpopt'
Generate code that uses (does not use) the optional PowerPC architecture instructions in the General Purpose group, including floating-point square root. 

`recip-precision'
`no-recip-precision'
Assume (do not assume) that the reciprocal estimate instructions provide higher precision estimates than is mandated by the powerpc ABI. 

`string'
`no-string'
Generate code that uses (does not use) the load string instructions and the store string word instructions to save multiple registers and do small block moves. 

`vsx'
`no-vsx'
Generate code that uses (does not use) vector/scalar (VSX) instructions, and also enable the use of built-in functions that allow more direct access to the VSX instruction set. In 32-bit code, you cannot enable VSX or Altivec instructions unless -mabi=altivec was used on the command line. 

`friz'
`no-friz'
Generate (do not generate) the friz instruction when the -funsafe-math-optimizations option is used to optimize rounding a floating point value to 64-bit integer and back to floating point. The friz instruction does not return the same value if the floating point number is too large to fit in an integer. 

`avoid-indexed-addresses'
`no-avoid-indexed-addresses'
Generate code that tries to avoid (not avoid) the use of indexed load or store instructions. 

`paired'
`no-paired'
Generate code that uses (does not use) the generation of PAIRED simd instructions. 

`longcall'
`no-longcall'
Generate code that assumes (does not assume) that all calls are far away so that a longer more expensive calling sequence is required. 

`cpu=CPU'
Specify the architecture to generate code for when compiling the function. If you select the target("cpu=power7") attribute when generating 32-bit code, VSX and Altivec instructions are not generated unless you use the -mabi=altivec option on the command line. 

`tune=TUNE'
Specify the architecture to tune for when compiling the function. If you do not specify the target("tune=TUNE") attribute and you do specify the target("cpu=CPU") attribute, compilation will tune for the CPU architecture, and not the default tuning specified on the command line. 
On the 386/x86_64 and PowerPC backends, you can use either multiple strings to specify multiple options, or you can separate the option with a comma (,). 

On the 386/x86_64 and PowerPC backends, the inliner will not inline a function that has different target options than the caller, unless the callee has a subset of the target options of the caller. For example a function declared with target("sse3") can inline a function with target("sse2"), since -msse3 implies -msse2. 

The target attribute is not implemented in GCC versions earlier than 4.4 for the i386/x86_64 and 4.6 for the PowerPC backends. It is not currently implemented for other backends. 


tiny_data
Use this attribute on the H8/300H and H8S to indicate that the specified variable should be placed into the tiny data section. The compiler will generate more efficient code for loads and stores on data in the tiny data section. Note the tiny data area is limited to slightly under 32kbytes of data. 

trap_exit
Use this attribute on the SH for an interrupt_handler to return using trapa instead of rte. This attribute expects an integer argument specifying the trap number to be used. 

unused
This attribute, attached to a function, means that the function is meant to be possibly unused. GCC will not produce a warning for this function. 

used
This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly. 
When applied to a member function of a C++ class template, the attribute also means that the function will be instantiated if the class itself is instantiated. 


version_id
This IA64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use version level functioning for some system calls. 
          extern int foo () __attribute__((version_id ("20040821")));
     
Calls to foo will be mapped to calls to foo{20040821}. 


visibility ("visibility_type")
This attribute affects the linkage of the declaration to which it is attached. There are four supported visibility_type values: default, hidden, protected or internal visibility. 
          void __attribute__ ((visibility ("protected")))
          f () { /* Do something. */; }
          int i __attribute__ ((visibility ("hidden")));
     
The possible values of visibility_type correspond to the visibility settings in the ELF gABI. 

default
Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities. 
On ELF, default visibility means that the declaration is visible to other modules and, in shared libraries, means that the declared entity may be overridden. 

On Darwin, default visibility means that the declaration is visible to other modules. 

Default visibility corresponds to “external linkage” in the language. 


hidden
Hidden visibility indicates that the entity declared will have a new form of linkage, which we'll call “hidden linkage”. Two declarations of an object with hidden linkage refer to the same object if they are in the same shared object. 

internal
Internal visibility is like hidden visibility, but with additional processor specific semantics. Unless otherwise specified by the psABI, GCC defines internal visibility to mean that a function is never called from another module. Compare this with hidden functions which, while they cannot be referenced directly by other modules, can be referenced indirectly via function pointers. By indicating that a function cannot be called from outside the module, GCC may for instance omit the load of a PIC register since it is known that the calling function loaded the correct value. 

protected
Protected visibility is like default visibility except that it indicates that references within the defining module will bind to the definition in that module. That is, the declared entity cannot be overridden by another module. 
All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the `.visibility' pseudo-op). Default visibility is supported everywhere. Hidden visibility is supported on Darwin targets. 

The visibility attribute should be applied only to declarations which would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute. 

In C++, the visibility attribute applies to types as well as functions and objects, because in C++ types have linkage. A class must not have greater visibility than its non-static data member types and bases, and class members default to the visibility of their class. Also, a declaration without explicit visibility is limited to the visibility of its type. 

In C++, you can mark member functions and static member variables of a class with the visibility attribute. This is useful if you know a particular method or static member variable should only be used from one shared object; then you can mark it hidden while the rest of the class has default visibility. Care must be taken to avoid breaking the One Definition Rule; for example, it is usually not useful to mark an inline method as hidden without marking the whole class as hidden. 

A C++ namespace declaration can also have the visibility attribute. This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using `#pragma GCC visibility' before and after the namespace definition (see Visibility Pragmas). 

In C++, if a template argument has limited visibility, this restriction is implicitly propagated to the template instantiation. Otherwise, template instantiations and specializations default to the visibility of their template. 

If both the template and enclosing class have explicit visibility, the visibility from the template is used. 


vliw
On MeP, the vliw attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command line options. 

warn_unused_result
The warn_unused_result attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as realloc. 
          int fn () __attribute__ ((warn_unused_result));
          int foo ()
          {
            if (fn () < 0) return -1;
            fn ();
            return 0;
          }
     
results in warning on line 5. 


weak
The weak attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions which can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker. 

weakref
weakref ("target")
The weakref attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an alias attribute naming the target symbol. Optionally, the target may be given as an argument to weakref itself. In either case, weakref implicitly marks the declaration as weak. Without a target, given as an argument to weakref or to alias, weakref is equivalent to weak. 
          static int x() __attribute__ ((weakref ("y")));
          /* is equivalent to... */
          static int x() __attribute__ ((weak, weakref, alias ("y")));
          /* and to... */
          static int x() __attribute__ ((weakref));
          static int x() __attribute__ ((alias ("y")));
     
A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a weak undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition will be required for the symbol, not necessarily in the same translation unit. 

The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a reloadable link on them. 

At present, a declaration to which weakref is attached can only be static. 

You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following an attribute declaration with another attribute declaration. 

Some people object to the __attribute__ feature, suggesting that ISO C's #pragma should be used instead. At the time __attribute__ was designed, there were two reasons for not doing this. 

It is impossible to generate #pragma commands from a macro. 
There is no telling what the same #pragma might mean in another compiler. 
These two reasons applied to almost any application that might have been proposed for #pragma. It was basically a mistake to use #pragma for anything. 

The ISO C99 standard includes _Pragma, which now allows pragmas to be generated from macros. In addition, a #pragma GCC namespace is now in use for GCC-specific pragmas. However, it has been found convenient to use __attribute__ to achieve a natural attachment of attributes to their corresponding declarations, whereas #pragma GCC is of use for constructs that do not naturally form part of the grammar. See Pragmas Accepted by GCC. 
